//
//  UIExtendedView.swift
//  WhatToWearToday
//
//  Created by Egzon Pllana on 3/20/20.
//  Copyright © 2020 Native Coders. All rights reserved.
//

import UIKit

@IBDesignable open class UIExtendedView: UIView {

    // MARK: - Inspectable attributes

    /**
     When positive, the background of the layer will be drawn with
     rounded corners. Also effects the mask generated by the
     `masksToBounds' property. Defaults to zero. Animatable.

     (equivalent to layer.cornerRadius)
     */
    @IBInspectable open var cornerRadius: CGFloat {
        get { return layer.cornerRadius }
        set {
            layer.cornerRadius = max( 0.0, min( newValue, min( bounds.width, bounds.height ) / 2.0 ))
            // Apply shadowPath for performance
            shadowPath = UIBezierPath(roundedRect: bounds, cornerRadius: layer.cornerRadius).cgPath
        }
    }

    /**
     The width of the layer's border, inset from the layer bounds. The
     border is composited above the layer's content and sublayers and
     includes the effects of the `cornerRadius' property. Defaults to
     zero. Animatable.

     (equivalent to layer.borderWidth)
     */
    @IBInspectable public var borderWidth: CGFloat {
        get { return layer.borderWidth }
        set { layer.borderWidth = newValue }
    }

    /**
     The color of the layer's border. Defaults to opaque black. Colors
     created from tiled patterns are supported. Animatable.

     (equivalent to layer.borderColor)
     */
    @IBInspectable public var borderColor: UIColor? {
        get {
            guard let color = layer.borderColor else { return nil }
            return UIColor(cgColor: color)
        }
        set { layer.borderColor = newValue?.cgColor }
    }

    /**
     The color of the shadow. Defaults to opaque black. Colors created
     from patterns are currently NOT supported. Animatable.

     (equivalent to layer.shadowColor)
     */
    @IBInspectable public var shadowColor: UIColor? {
        get {
            guard let color = layer.shadowColor else { return nil }
            return UIColor(cgColor: color)
        }
        set { layer.shadowColor = newValue?.cgColor }
    }

    /**
     The opacity of the shadow. Defaults to 0. Specifying a value outside the
     [0,1] range will give undefined results. Animatable.

     (equivalent to layer.shadowOpacity)
     */
    @IBInspectable public var shadowOpacity: Float {
        get { return layer.shadowOpacity }
        set { layer.shadowOpacity = newValue }
    }

    /**
     The shadow offset. Defaults to (0, -3). Animatable.

     (equivalent to layer.shadowOffset)
     */
    @IBInspectable public var shadowOffset: CGSize {
        get { return layer.shadowOffset }
        set { layer.shadowOffset = newValue }
    }

    /**
     The blur radius used to create the shadow. Defaults to 3. Animatable.

     (equivalent to layer.shadowRadius)
     */
    @IBInspectable public var shadowRadius: CGFloat {
        get { return layer.shadowRadius }
        set { layer.shadowRadius = newValue }
    }

    /**
     The shape of the layer’s shadow. Animatable.

     (equivalent to layer.shadowPath)
     */
    fileprivate var shadowPath: CGPath? {
        get { return layer.shadowPath }
        set { layer.shadowPath = newValue }
    }

    // MARK: - Initializers

    override public init(frame: CGRect) {
        super.init(frame: frame)
    }

    required public init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        // Decode attributes
        cornerRadius = CGFloat(aDecoder.decodeFloat(forKey: EncodingKey.cornerRadius.rawValue))
        shadowOpacity = aDecoder.decodeFloat(forKey: EncodingKey.shadowOpacity.rawValue)
        shadowRadius = CGFloat(aDecoder.decodeFloat(forKey: EncodingKey.shadowRadius.rawValue))
        shadowColor = aDecoder.decodeObject(forKey: EncodingKey.shadowColor.rawValue) as? UIColor
        shadowOffset = aDecoder.decodeCGSize(forKey: EncodingKey.shadowOffset.rawValue)
        borderWidth = CGFloat(aDecoder.decodeFloat(forKey: EncodingKey.borderWidth.rawValue))
        borderColor = aDecoder.decodeObject(forKey: EncodingKey.borderColor.rawValue) as? UIColor
    }

    // MARK: - Layout updates

    override open func layoutSubviews() {
        super.layoutSubviews()

        // Recompute cornerRadius from bounds
        cornerRadius = max(0.0, min(cornerRadius, min(bounds.width, bounds.height) / 2.0))
        shadowPath = UIBezierPath(roundedRect: bounds, cornerRadius: layer.cornerRadius).cgPath
    }

}

// MARK: - NSCoding

extension UIExtendedView/*: NSCoding*/ {

    fileprivate enum EncodingKey: String {
        case cornerRadius
        case borderWidth
        case borderColor
        case shadowColor
        case shadowOpacity
        case shadowOffset
        case shadowRadius
    }

    open override func encode(with aCoder: NSCoder) {
        super.encode(with: aCoder)
        aCoder.encode(Float(cornerRadius), forKey: EncodingKey.cornerRadius.rawValue)
        aCoder.encode(shadowOpacity, forKey: EncodingKey.shadowOpacity.rawValue)
        aCoder.encode(Float(shadowRadius), forKey: EncodingKey.shadowRadius.rawValue)
        aCoder.encode(shadowColor, forKey: EncodingKey.shadowColor.rawValue)
        aCoder.encode(shadowOffset, forKey: EncodingKey.shadowOffset.rawValue)
        aCoder.encode(Float(borderWidth), forKey: EncodingKey.borderWidth.rawValue)
        aCoder.encode(borderColor, forKey: EncodingKey.borderColor.rawValue)
    }

}
